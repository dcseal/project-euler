#!/usr/bin/env python
import numpy as np

def f(x):
    return np.sin(10.0*x)
def fp(x):
    return 10.0 * np.cos(10.0*x)

def main(method):

    tol = 1e-12

    num_iter = 0
    max_iter = 50000
    xn = 0.61

    x    = np.zeros(max_iter+2)
    x[0] = xn
    while( np.abs( f(xn) ) > tol ):

        "one function evaluation"
        fn = f(xn)

        "Find qn"
        if( method == 'Newton' ):
            qn = 1 / fp(xn)
        elif ( method == 'Other'):
            qn = fn / (f(xn + fn)  - fn )

        "update x, and counter"
        xn = xn - qn * fn
        num_iter = num_iter + 1

        "save the sequence generated by the method"
        x[num_iter] = xn

        "quick error check"
        if( num_iter > max_iter ):

            print '*******************************************************'
            print '      **Method ' + method + ' failed to converge**'
            print '        too many iterations: num_iter = %i' % num_iter
            print '*******************************************************'

            return

    "user output stuff"
    print '   Printing output information for method:' + method
    print '  xn = %2.8e, num_iter = %i, f(xn) = %2.8e' % (xn, num_iter, f(xn))

    x = x[0:num_iter]
    print x

    
    if( method == 'Other' ):
        xnp1 = x[2:]
        xn   = x[1:num_iter-1]
        xnm1 = x[0:num_iter-2]
        err = np.abs( xnp1 - xn ) / np.abs( xn - xnm1 )

        print 'errors are given by:'
        for n in range(0,len(err)):
            print '   err[%3i ] = %2.8e' % (n, err[n])

    return x

if __name__ == '__main__':

    method = 'Newton'
    main('Newton')

    print ' ' 

    main('Other')

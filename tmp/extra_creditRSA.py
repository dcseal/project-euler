from number_theory import find_root, solve_system, gcd

def print_ascii(M, maxM=0 ):
    """This function prints M as an ascii string"""

    # mod out by a max value if specified
    if( maxM > 0 ):
        M = M%maxM

    s = []

    #print 'in number -> char step:'
    a = 256
    while( M != 0 ):

        r = M%256
        #print 'pulling character = ', chr(r)
        s.insert( 0, chr(r) )
        M = M - r
        M = M / a

    s.reverse()
    return ''.join(s)

def run_problem():
    """Main Driver for the extra credit problem"""

    # public keys from the problem
    n1 = 8863311460481781141746416676937941075153709659930434578989576454853657824757125219971944776154496375261537574471193394889882989089525667336788696489143321703785633024846473739853542155131471765883950963709458425003103527483331918530627858660949272208501136880181401361437034621

    n2 = 8863311460481781141746416676937941075153709659930434578989576454853657824757125219971944776154496375261537574471193391387559088717587680322284863076552503650556227344117936523740217549860922144393964978935696177238190245580706063128502771258186465823214390003235691996303304527

    n3 = 8863311460481781141746416676937941075153709659930434578989576454853657824757125219971944776154496375261537574471193391385407891698062317496575205108824871544510374815234856205738766004136828520805419335875843560760813014018735860250929031609054577089970896036106983556531583303

    # encrypted (cipher text) sent to each party
    C1 = 4577680065415368161648540884550232673528863129874614143903085721197264729467287391728239488766293702878779569458876181042624925557540071289584555692433528201730360701157483100163799951165081143270882917025409619990398953861880538175231585652010025281079755920991602465584286718

    C2 = 2940124463515328311271793477152822171601128905910679917132860419093728196677381616596595963049224436649008655484870188073648668140168657423122181636806974474782033479946998431756340802758166088718503769194836550239068162754375749734632251720740530843335647009097024868877766216

    C3 = 1944990884872864570293582284852287219644000554796598757253502734697193299590620296722550094514493330603278084907134325657042465763074210737354537277376595314254301885328228128811484849142598263733960309950893225645530668131875931580139812579408862698979500298119315275949230573

    # make sure the keys are relatively prime
    assert( gcd(n1,n2) == 1 )
    assert( gcd(n1,n3) == 1 )
    assert( gcd(n2,n3) == 1 )

    M3 = solve_system([C1,C2,C3], [n1,n2,n3])

    #print 'finding root'
    M = find_root(M3,3)

    assert( M**3 == M3 )
    assert( C1 == M3 % n1 )
    assert( C2 == M3 % n2 )
    assert( C3 == M3 % n3 )

    #print 'Printing the found string!'
    print 'The deciphered key = ', print_ascii(M,2**700)

############# Below here is testing code ###################

def run_single_test():
    print 'testing find_root'
    for M in range(2,100):
        for n in range(2,4):
            print 'find_root(%d,%d) = %d ' % (M,n,find_root(M,n))

def test_print_ascii():
    """See if we can construct and print a single message"""

    msg = 'hi mom!'
    msg = list(msg)

    M = 0
    a = 1

    #print 'in char -> number step:'
    for n in range(len(msg)):

        c = msg.pop()
        M = M + a*ord( c )
        a = a*256

        #print 'adding character = ', c

    #print print_ascii(M,a)


if __name__=='__main__':

    run_problem()
